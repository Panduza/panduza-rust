// automatically generated by the FlatBuffers compiler, do not modify

// @generated

#[allow(unused_imports, dead_code)]
pub mod panduza {

    use core::cmp::Ordering;
    use core::mem;

    use flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_PAYLOAD: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_PAYLOAD: u8 = 10;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_PAYLOAD: [Payload; 11] = [
        Payload::NONE,
        Payload::Structure,
        Payload::Context,
        Payload::Status,
        Payload::Notification,
        Payload::Boolean,
        Payload::Bytes,
        Payload::Number,
        Payload::Trigger,
        Payload::String,
        Payload::VectorF32,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Payload(pub u8);
    #[allow(non_upper_case_globals)]
    impl Payload {
        pub const NONE: Self = Self(0);
        pub const Structure: Self = Self(1);
        pub const Context: Self = Self(2);
        pub const Status: Self = Self(3);
        pub const Notification: Self = Self(4);
        pub const Boolean: Self = Self(5);
        pub const Bytes: Self = Self(6);
        pub const Number: Self = Self(7);
        pub const Trigger: Self = Self(8);
        pub const String: Self = Self(9);
        pub const VectorF32: Self = Self(10);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 10;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::Structure,
            Self::Context,
            Self::Status,
            Self::Notification,
            Self::Boolean,
            Self::Bytes,
            Self::Number,
            Self::Trigger,
            Self::String,
            Self::VectorF32,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::Structure => Some("Structure"),
                Self::Context => Some("Context"),
                Self::Status => Some("Status"),
                Self::Notification => Some("Notification"),
                Self::Boolean => Some("Boolean"),
                Self::Bytes => Some("Bytes"),
                Self::Number => Some("Number"),
                Self::Trigger => Some("Trigger"),
                Self::String => Some("String"),
                Self::VectorF32 => Some("VectorF32"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for Payload {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Payload {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for Payload {
        type Output = Payload;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for Payload {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Payload {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Payload {}
    pub struct PayloadUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_NODE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_NODE: i8 = 3;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_NODE: [Node; 4] = [
        Node::Undefined,
        Node::Instance,
        Node::Class,
        Node::Attribute,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Node(pub i8);
    #[allow(non_upper_case_globals)]
    impl Node {
        pub const Undefined: Self = Self(0);
        pub const Instance: Self = Self(1);
        pub const Class: Self = Self(2);
        pub const Attribute: Self = Self(3);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 3;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::Undefined,
            Self::Instance,
            Self::Class,
            Self::Attribute,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Undefined => Some("Undefined"),
                Self::Instance => Some("Instance"),
                Self::Class => Some("Class"),
                Self::Attribute => Some("Attribute"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for Node {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Node {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for Node {
        type Output = Node;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for Node {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Node {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Node {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_SIPREFIX: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_SIPREFIX: u8 = 8;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_SIPREFIX: [SIPrefix; 9] = [
        SIPrefix::NONE,
        SIPrefix::PICO,
        SIPrefix::NANO,
        SIPrefix::MICRO,
        SIPrefix::MILLI,
        SIPrefix::KILO,
        SIPrefix::MEGA,
        SIPrefix::GIGA,
        SIPrefix::TERA,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct SIPrefix(pub u8);
    #[allow(non_upper_case_globals)]
    impl SIPrefix {
        pub const NONE: Self = Self(0);
        pub const PICO: Self = Self(1);
        pub const NANO: Self = Self(2);
        pub const MICRO: Self = Self(3);
        pub const MILLI: Self = Self(4);
        pub const KILO: Self = Self(5);
        pub const MEGA: Self = Self(6);
        pub const GIGA: Self = Self(7);
        pub const TERA: Self = Self(8);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 8;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::PICO,
            Self::NANO,
            Self::MICRO,
            Self::MILLI,
            Self::KILO,
            Self::MEGA,
            Self::GIGA,
            Self::TERA,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::PICO => Some("PICO"),
                Self::NANO => Some("NANO"),
                Self::MICRO => Some("MICRO"),
                Self::MILLI => Some("MILLI"),
                Self::KILO => Some("KILO"),
                Self::MEGA => Some("MEGA"),
                Self::GIGA => Some("GIGA"),
                Self::TERA => Some("TERA"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for SIPrefix {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for SIPrefix {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for SIPrefix {
        type Output = SIPrefix;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for SIPrefix {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for SIPrefix {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for SIPrefix {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_SIUNIT: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_SIUNIT: u8 = 14;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_SIUNIT: [SIUnit; 15] = [
        SIUnit::NONE,
        SIUnit::METER,
        SIUnit::KILOGRAM,
        SIUnit::SECOND,
        SIUnit::AMPERE,
        SIUnit::KELVIN,
        SIUnit::MOLE,
        SIUnit::CANDELA,
        SIUnit::HERTZ,
        SIUnit::VOLT,
        SIUnit::OHM,
        SIUnit::WATT,
        SIUnit::FARAD,
        SIUnit::HENRY,
        SIUnit::CELSIUS,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct SIUnit(pub u8);
    #[allow(non_upper_case_globals)]
    impl SIUnit {
        pub const NONE: Self = Self(0);
        pub const METER: Self = Self(1);
        pub const KILOGRAM: Self = Self(2);
        pub const SECOND: Self = Self(3);
        pub const AMPERE: Self = Self(4);
        pub const KELVIN: Self = Self(5);
        pub const MOLE: Self = Self(6);
        pub const CANDELA: Self = Self(7);
        pub const HERTZ: Self = Self(8);
        pub const VOLT: Self = Self(9);
        pub const OHM: Self = Self(10);
        pub const WATT: Self = Self(11);
        pub const FARAD: Self = Self(12);
        pub const HENRY: Self = Self(13);
        pub const CELSIUS: Self = Self(14);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 14;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::METER,
            Self::KILOGRAM,
            Self::SECOND,
            Self::AMPERE,
            Self::KELVIN,
            Self::MOLE,
            Self::CANDELA,
            Self::HERTZ,
            Self::VOLT,
            Self::OHM,
            Self::WATT,
            Self::FARAD,
            Self::HENRY,
            Self::CELSIUS,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::METER => Some("METER"),
                Self::KILOGRAM => Some("KILOGRAM"),
                Self::SECOND => Some("SECOND"),
                Self::AMPERE => Some("AMPERE"),
                Self::KELVIN => Some("KELVIN"),
                Self::MOLE => Some("MOLE"),
                Self::CANDELA => Some("CANDELA"),
                Self::HERTZ => Some("HERTZ"),
                Self::VOLT => Some("VOLT"),
                Self::OHM => Some("OHM"),
                Self::WATT => Some("WATT"),
                Self::FARAD => Some("FARAD"),
                Self::HENRY => Some("HENRY"),
                Self::CELSIUS => Some("CELSIUS"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for SIUnit {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for SIUnit {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for SIUnit {
        type Output = SIUnit;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for SIUnit {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for SIUnit {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for SIUnit {}
    // struct Timestamp, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Timestamp(pub [u8; 16]);
    impl Default for Timestamp {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for Timestamp {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Timestamp")
                .field("secs", &self.secs())
                .field("nanos", &self.nanos())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Timestamp {}
    impl<'a> flatbuffers::Follow<'a> for Timestamp {
        type Inner = &'a Timestamp;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Timestamp>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Timestamp {
        type Inner = &'a Timestamp;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Timestamp>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Timestamp {
        type Output = Timestamp;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const Timestamp as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for Timestamp {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Timestamp {
        #[allow(clippy::too_many_arguments)]
        pub fn new(secs: u64, nanos: u32) -> Self {
            let mut s = Self([0; 16]);
            s.set_secs(secs);
            s.set_nanos(nanos);
            s
        }

        pub fn secs(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_secs(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn nanos(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_nanos(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    pub enum HeaderOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Header<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Header<'a> {
        type Inner = Header<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Header<'a> {
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;
        pub const VT_SOURCE: flatbuffers::VOffsetT = 6;
        pub const VT_SEQUENCE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Header { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args HeaderArgs<'args>,
        ) -> flatbuffers::WIPOffset<Header<'bldr>> {
            let mut builder = HeaderBuilder::new(_fbb);
            if let Some(x) = args.timestamp {
                builder.add_timestamp(x);
            }
            builder.add_sequence(args.sequence);
            builder.add_source(args.source);
            builder.finish()
        }

        #[inline]
        pub fn timestamp(&self) -> Option<&'a Timestamp> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Timestamp>(Header::VT_TIMESTAMP, None) }
        }
        #[inline]
        pub fn source(&self) -> u16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u16>(Header::VT_SOURCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn sequence(&self) -> u16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u16>(Header::VT_SEQUENCE, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Header<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Timestamp>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<u16>("source", Self::VT_SOURCE, false)?
                .visit_field::<u16>("sequence", Self::VT_SEQUENCE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct HeaderArgs<'a> {
        pub timestamp: Option<&'a Timestamp>,
        pub source: u16,
        pub sequence: u16,
    }
    impl<'a> Default for HeaderArgs<'a> {
        #[inline]
        fn default() -> Self {
            HeaderArgs {
                timestamp: None,
                source: 0,
                sequence: 0,
            }
        }
    }

    pub struct HeaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HeaderBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: &Timestamp) {
            self.fbb_
                .push_slot_always::<&Timestamp>(Header::VT_TIMESTAMP, timestamp);
        }
        #[inline]
        pub fn add_source(&mut self, source: u16) {
            self.fbb_.push_slot::<u16>(Header::VT_SOURCE, source, 0);
        }
        #[inline]
        pub fn add_sequence(&mut self, sequence: u16) {
            self.fbb_.push_slot::<u16>(Header::VT_SEQUENCE, sequence, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> HeaderBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            HeaderBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Header<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Header");
            ds.field("timestamp", &self.timestamp());
            ds.field("source", &self.source());
            ds.field("sequence", &self.sequence());
            ds.finish()
        }
    }
    pub enum MessageOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Message<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Message<'a> {
        type Inner = Message<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Message<'a> {
        pub const VT_HEADER: flatbuffers::VOffsetT = 4;
        pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Message { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args MessageArgs<'args>,
        ) -> flatbuffers::WIPOffset<Message<'bldr>> {
            let mut builder = MessageBuilder::new(_fbb);
            if let Some(x) = args.payload {
                builder.add_payload(x);
            }
            if let Some(x) = args.header {
                builder.add_header(x);
            }
            builder.add_payload_type(args.payload_type);
            builder.finish()
        }

        #[inline]
        pub fn header(&self) -> Option<Header<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Header>>(Message::VT_HEADER, None)
            }
        }
        #[inline]
        pub fn payload_type(&self) -> Payload {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<Payload>(Message::VT_PAYLOAD_TYPE, Some(Payload::NONE))
                    .unwrap()
            }
        }
        #[inline]
        pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        Message::VT_PAYLOAD,
                        None,
                    )
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_structure(&self) -> Option<Structure<'a>> {
            if self.payload_type() == Payload::Structure {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Structure::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_context(&self) -> Option<Context<'a>> {
            if self.payload_type() == Payload::Context {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Context::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_status(&self) -> Option<Status<'a>> {
            if self.payload_type() == Payload::Status {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Status::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_notification(&self) -> Option<Notification<'a>> {
            if self.payload_type() == Payload::Notification {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Notification::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_boolean(&self) -> Option<Boolean<'a>> {
            if self.payload_type() == Payload::Boolean {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Boolean::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_bytes(&self) -> Option<Bytes<'a>> {
            if self.payload_type() == Payload::Bytes {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Bytes::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_number(&self) -> Option<Number<'a>> {
            if self.payload_type() == Payload::Number {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Number::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_trigger(&self) -> Option<Trigger<'a>> {
            if self.payload_type() == Payload::Trigger {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Trigger::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_string(&self) -> Option<String<'a>> {
            if self.payload_type() == Payload::String {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { String::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_vector_f32(&self) -> Option<VectorF32<'a>> {
            if self.payload_type() == Payload::VectorF32 {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { VectorF32::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Message<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Header>>(
                    "header",
                    Self::VT_HEADER,
                    false,
                )?
                .visit_union::<Payload, _>(
                    "payload_type",
                    Self::VT_PAYLOAD_TYPE,
                    "payload",
                    Self::VT_PAYLOAD,
                    false,
                    |key, v, pos| match key {
                        Payload::Structure => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Structure>>(
                                "Payload::Structure",
                                pos,
                            ),
                        Payload::Context => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Context>>(
                                "Payload::Context",
                                pos,
                            ),
                        Payload::Status => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Status>>(
                                "Payload::Status",
                                pos,
                            ),
                        Payload::Notification => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Notification>>(
                                "Payload::Notification",
                                pos,
                            ),
                        Payload::Boolean => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Boolean>>(
                                "Payload::Boolean",
                                pos,
                            ),
                        Payload::Bytes => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Bytes>>(
                                "Payload::Bytes",
                                pos,
                            ),
                        Payload::Number => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Number>>(
                                "Payload::Number",
                                pos,
                            ),
                        Payload::Trigger => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Trigger>>(
                                "Payload::Trigger",
                                pos,
                            ),
                        Payload::String => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<String>>(
                                "Payload::String",
                                pos,
                            ),
                        Payload::VectorF32 => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<VectorF32>>(
                                "Payload::VectorF32",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MessageArgs<'a> {
        pub header: Option<flatbuffers::WIPOffset<Header<'a>>>,
        pub payload_type: Payload,
        pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for MessageArgs<'a> {
        #[inline]
        fn default() -> Self {
            MessageArgs {
                header: None,
                payload_type: Payload::NONE,
                payload: None,
            }
        }
    }

    pub struct MessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MessageBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Header>>(Message::VT_HEADER, header);
        }
        #[inline]
        pub fn add_payload_type(&mut self, payload_type: Payload) {
            self.fbb_
                .push_slot::<Payload>(Message::VT_PAYLOAD_TYPE, payload_type, Payload::NONE);
        }
        #[inline]
        pub fn add_payload(
            &mut self,
            payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_PAYLOAD, payload);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> MessageBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            MessageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Message<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Message");
            ds.field("header", &self.header());
            ds.field("payload_type", &self.payload_type());
            match self.payload_type() {
                Payload::Structure => {
                    if let Some(x) = self.payload_as_structure() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Payload::Context => {
                    if let Some(x) = self.payload_as_context() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Payload::Status => {
                    if let Some(x) = self.payload_as_status() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Payload::Notification => {
                    if let Some(x) = self.payload_as_notification() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Payload::Boolean => {
                    if let Some(x) = self.payload_as_boolean() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Payload::Bytes => {
                    if let Some(x) = self.payload_as_bytes() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Payload::Number => {
                    if let Some(x) = self.payload_as_number() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Payload::Trigger => {
                    if let Some(x) = self.payload_as_trigger() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Payload::String => {
                    if let Some(x) = self.payload_as_string() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                Payload::VectorF32 => {
                    if let Some(x) = self.payload_as_vector_f32() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("payload", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum StructureOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Structure<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Structure<'a> {
        type Inner = Structure<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Structure<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_NODE: flatbuffers::VOffsetT = 6;
        pub const VT_CHILDREN: flatbuffers::VOffsetT = 8;
        pub const VT_TAGS: flatbuffers::VOffsetT = 10;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 12;
        pub const VT_MODE: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Structure { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args StructureArgs<'args>,
        ) -> flatbuffers::WIPOffset<Structure<'bldr>> {
            let mut builder = StructureBuilder::new(_fbb);
            if let Some(x) = args.mode {
                builder.add_mode(x);
            }
            if let Some(x) = args.type_ {
                builder.add_type_(x);
            }
            if let Some(x) = args.tags {
                builder.add_tags(x);
            }
            if let Some(x) = args.children {
                builder.add_children(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_node(args.node);
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Structure::VT_NAME, None)
            }
        }
        #[inline]
        pub fn node(&self) -> Node {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<Node>(Structure::VT_NODE, Some(Node::Undefined))
                    .unwrap()
            }
        }
        #[inline]
        pub fn children(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Structure<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Structure>>,
                >>(Structure::VT_CHILDREN, None)
            }
        }
        #[inline]
        pub fn tags(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Structure::VT_TAGS, None)
            }
        }
        #[inline]
        pub fn type_(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Structure::VT_TYPE_, None)
            }
        }
        #[inline]
        pub fn mode(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Structure::VT_MODE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Structure<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<Node>("node", Self::VT_NODE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Structure>>,
                >>("children", Self::VT_CHILDREN, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("tags", Self::VT_TAGS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mode", Self::VT_MODE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StructureArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub node: Node,
        pub children: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Structure<'a>>>,
            >,
        >,
        pub tags: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
        pub mode: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for StructureArgs<'a> {
        #[inline]
        fn default() -> Self {
            StructureArgs {
                name: None,
                node: Node::Undefined,
                children: None,
                tags: None,
                type_: None,
                mode: None,
            }
        }
    }

    pub struct StructureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StructureBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Structure::VT_NAME, name);
        }
        #[inline]
        pub fn add_node(&mut self, node: Node) {
            self.fbb_
                .push_slot::<Node>(Structure::VT_NODE, node, Node::Undefined);
        }
        #[inline]
        pub fn add_children(
            &mut self,
            children: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Structure<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Structure::VT_CHILDREN, children);
        }
        #[inline]
        pub fn add_tags(
            &mut self,
            tags: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Structure::VT_TAGS, tags);
        }
        #[inline]
        pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Structure::VT_TYPE_, type_);
        }
        #[inline]
        pub fn add_mode(&mut self, mode: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Structure::VT_MODE, mode);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> StructureBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            StructureBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Structure<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Structure<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Structure");
            ds.field("name", &self.name());
            ds.field("node", &self.node());
            ds.field("children", &self.children());
            ds.field("tags", &self.tags());
            ds.field("type_", &self.type_());
            ds.field("mode", &self.mode());
            ds.finish()
        }
    }
    pub enum ContextOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Context<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Context<'a> {
        type Inner = Context<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Context<'a> {
        pub const VT_TOPIC: flatbuffers::VOffsetT = 4;
        pub const VT_CONTEXT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Context { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ContextArgs<'args>,
        ) -> flatbuffers::WIPOffset<Context<'bldr>> {
            let mut builder = ContextBuilder::new(_fbb);
            if let Some(x) = args.context {
                builder.add_context(x);
            }
            if let Some(x) = args.topic {
                builder.add_topic(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn topic(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Context::VT_TOPIC, None)
            }
        }
        #[inline]
        pub fn context(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Context::VT_CONTEXT, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Context<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("topic", Self::VT_TOPIC, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("context", Self::VT_CONTEXT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ContextArgs<'a> {
        pub topic: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub context: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for ContextArgs<'a> {
        #[inline]
        fn default() -> Self {
            ContextArgs {
                topic: None,
                context: None,
            }
        }
    }

    pub struct ContextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContextBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_topic(
            &mut self,
            topic: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Context::VT_TOPIC, topic);
        }
        #[inline]
        pub fn add_context(
            &mut self,
            context: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Context::VT_CONTEXT, context);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ContextBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ContextBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Context<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Context<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Context");
            ds.field("topic", &self.topic());
            ds.field("context", &self.context());
            ds.finish()
        }
    }
    pub enum UserEntryOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UserEntry<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UserEntry<'a> {
        type Inner = UserEntry<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UserEntry<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UserEntry { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UserEntryArgs<'args>,
        ) -> flatbuffers::WIPOffset<UserEntry<'bldr>> {
            let mut builder = UserEntryBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        #[inline]
        pub fn id(&self) -> u16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u16>(UserEntry::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UserEntry::VT_NAME, None)
            }
        }
    }

    impl flatbuffers::Verifiable for UserEntry<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u16>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UserEntryArgs<'a> {
        pub id: u16,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for UserEntryArgs<'a> {
        #[inline]
        fn default() -> Self {
            UserEntryArgs { id: 0, name: None }
        }
    }

    pub struct UserEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UserEntryBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u16) {
            self.fbb_.push_slot::<u16>(UserEntry::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UserEntry::VT_NAME, name);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UserEntryBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UserEntryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UserEntry<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UserEntry<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UserEntry");
            ds.field("id", &self.id());
            ds.field("name", &self.name());
            ds.finish()
        }
    }
    pub enum UsersOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Users<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Users<'a> {
        type Inner = Users<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Users<'a> {
        pub const VT_ENTRIES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Users { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UsersArgs<'args>,
        ) -> flatbuffers::WIPOffset<Users<'bldr>> {
            let mut builder = UsersBuilder::new(_fbb);
            if let Some(x) = args.entries {
                builder.add_entries(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn entries(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UserEntry<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UserEntry>>,
                >>(Users::VT_ENTRIES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Users<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<UserEntry>>,
                >>("entries", Self::VT_ENTRIES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UsersArgs<'a> {
        pub entries: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UserEntry<'a>>>,
            >,
        >,
    }
    impl<'a> Default for UsersArgs<'a> {
        #[inline]
        fn default() -> Self {
            UsersArgs { entries: None }
        }
    }

    pub struct UsersBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UsersBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_entries(
            &mut self,
            entries: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<UserEntry<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Users::VT_ENTRIES, entries);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UsersBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UsersBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Users<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Users<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Users");
            ds.field("entries", &self.entries());
            ds.finish()
        }
    }
    pub enum InstanceStatusOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct InstanceStatus<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for InstanceStatus<'a> {
        type Inner = InstanceStatus<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> InstanceStatus<'a> {
        pub const VT_INSTANCE: flatbuffers::VOffsetT = 4;
        pub const VT_STATE: flatbuffers::VOffsetT = 6;
        pub const VT_ERROR_STRING: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            InstanceStatus { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args InstanceStatusArgs<'args>,
        ) -> flatbuffers::WIPOffset<InstanceStatus<'bldr>> {
            let mut builder = InstanceStatusBuilder::new(_fbb);
            if let Some(x) = args.error_string {
                builder.add_error_string(x);
            }
            if let Some(x) = args.instance {
                builder.add_instance(x);
            }
            builder.add_state(args.state);
            builder.finish()
        }

        #[inline]
        pub fn instance(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(InstanceStatus::VT_INSTANCE, None)
            }
        }
        #[inline]
        pub fn state(&self) -> u16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u16>(InstanceStatus::VT_STATE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn error_string(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    InstanceStatus::VT_ERROR_STRING,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for InstanceStatus<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "instance",
                    Self::VT_INSTANCE,
                    false,
                )?
                .visit_field::<u16>("state", Self::VT_STATE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "error_string",
                    Self::VT_ERROR_STRING,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct InstanceStatusArgs<'a> {
        pub instance: Option<flatbuffers::WIPOffset<&'a str>>,
        pub state: u16,
        pub error_string: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for InstanceStatusArgs<'a> {
        #[inline]
        fn default() -> Self {
            InstanceStatusArgs {
                instance: None,
                state: 0,
                error_string: None,
            }
        }
    }

    pub struct InstanceStatusBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> InstanceStatusBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_instance(&mut self, instance: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                InstanceStatus::VT_INSTANCE,
                instance,
            );
        }
        #[inline]
        pub fn add_state(&mut self, state: u16) {
            self.fbb_
                .push_slot::<u16>(InstanceStatus::VT_STATE, state, 0);
        }
        #[inline]
        pub fn add_error_string(&mut self, error_string: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                InstanceStatus::VT_ERROR_STRING,
                error_string,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> InstanceStatusBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            InstanceStatusBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<InstanceStatus<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for InstanceStatus<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("InstanceStatus");
            ds.field("instance", &self.instance());
            ds.field("state", &self.state());
            ds.field("error_string", &self.error_string());
            ds.finish()
        }
    }
    pub enum StatusOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Status<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Status<'a> {
        type Inner = Status<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Status<'a> {
        pub const VT_INSTANCES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Status { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args StatusArgs<'args>,
        ) -> flatbuffers::WIPOffset<Status<'bldr>> {
            let mut builder = StatusBuilder::new(_fbb);
            if let Some(x) = args.instances {
                builder.add_instances(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn instances(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InstanceStatus<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InstanceStatus>>,
                >>(Status::VT_INSTANCES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Status<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InstanceStatus>>,
                >>("instances", Self::VT_INSTANCES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StatusArgs<'a> {
        pub instances: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InstanceStatus<'a>>>,
            >,
        >,
    }
    impl<'a> Default for StatusArgs<'a> {
        #[inline]
        fn default() -> Self {
            StatusArgs { instances: None }
        }
    }

    pub struct StatusBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StatusBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_instances(
            &mut self,
            instances: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<InstanceStatus<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Status::VT_INSTANCES, instances);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> StatusBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            StatusBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Status<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Status<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Status");
            ds.field("instances", &self.instances());
            ds.finish()
        }
    }
    pub enum NotificationOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Notification<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Notification<'a> {
        type Inner = Notification<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Notification<'a> {
        pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
        pub const VT_SOURCE: flatbuffers::VOffsetT = 6;
        pub const VT_MESSAGE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Notification { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args NotificationArgs<'args>,
        ) -> flatbuffers::WIPOffset<Notification<'bldr>> {
            let mut builder = NotificationBuilder::new(_fbb);
            if let Some(x) = args.message {
                builder.add_message(x);
            }
            if let Some(x) = args.source {
                builder.add_source(x);
            }
            builder.add_type_(args.type_);
            builder.finish()
        }

        #[inline]
        pub fn type_(&self) -> u16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u16>(Notification::VT_TYPE_, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn source(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Notification::VT_SOURCE, None)
            }
        }
        #[inline]
        pub fn message(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Notification::VT_MESSAGE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Notification<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u16>("type_", Self::VT_TYPE_, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "source",
                    Self::VT_SOURCE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "message",
                    Self::VT_MESSAGE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct NotificationArgs<'a> {
        pub type_: u16,
        pub source: Option<flatbuffers::WIPOffset<&'a str>>,
        pub message: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for NotificationArgs<'a> {
        #[inline]
        fn default() -> Self {
            NotificationArgs {
                type_: 0,
                source: None,
                message: None,
            }
        }
    }

    pub struct NotificationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NotificationBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_type_(&mut self, type_: u16) {
            self.fbb_.push_slot::<u16>(Notification::VT_TYPE_, type_, 0);
        }
        #[inline]
        pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Notification::VT_SOURCE, source);
        }
        #[inline]
        pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Notification::VT_MESSAGE, message);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> NotificationBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            NotificationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Notification<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Notification<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Notification");
            ds.field("type_", &self.type_());
            ds.field("source", &self.source());
            ds.field("message", &self.message());
            ds.finish()
        }
    }
    pub enum BooleanOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Boolean<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Boolean<'a> {
        type Inner = Boolean<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Boolean<'a> {
        pub const VT_VALUE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Boolean { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BooleanArgs,
        ) -> flatbuffers::WIPOffset<Boolean<'bldr>> {
            let mut builder = BooleanBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.finish()
        }

        #[inline]
        pub fn value(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Boolean::VT_VALUE, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Boolean<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BooleanArgs {
        pub value: bool,
    }
    impl<'a> Default for BooleanArgs {
        #[inline]
        fn default() -> Self {
            BooleanArgs { value: false }
        }
    }

    pub struct BooleanBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BooleanBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_value(&mut self, value: bool) {
            self.fbb_.push_slot::<bool>(Boolean::VT_VALUE, value, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BooleanBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BooleanBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Boolean<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Boolean<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Boolean");
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum BytesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Bytes<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Bytes<'a> {
        type Inner = Bytes<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Bytes<'a> {
        pub const VT_DATA: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Bytes { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BytesArgs<'args>,
        ) -> flatbuffers::WIPOffset<Bytes<'bldr>> {
            let mut builder = BytesBuilder::new(_fbb);
            if let Some(x) = args.data {
                builder.add_data(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Bytes::VT_DATA,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Bytes<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "data",
                    Self::VT_DATA,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct BytesArgs<'a> {
        pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for BytesArgs<'a> {
        #[inline]
        fn default() -> Self {
            BytesArgs { data: None }
        }
    }

    pub struct BytesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BytesBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Bytes::VT_DATA, data);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BytesBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BytesBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Bytes<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Bytes<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Bytes");
            ds.field("data", &self.data());
            ds.finish()
        }
    }
    pub enum UnitOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Unit<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Unit<'a> {
        type Inner = Unit<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Unit<'a> {
        pub const VT_PREFIX: flatbuffers::VOffsetT = 4;
        pub const VT_UNIT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Unit { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UnitArgs,
        ) -> flatbuffers::WIPOffset<Unit<'bldr>> {
            let mut builder = UnitBuilder::new(_fbb);
            builder.add_unit(args.unit);
            builder.add_prefix(args.prefix);
            builder.finish()
        }

        #[inline]
        pub fn prefix(&self) -> SIPrefix {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<SIPrefix>(Unit::VT_PREFIX, Some(SIPrefix::NONE))
                    .unwrap()
            }
        }
        #[inline]
        pub fn unit(&self) -> SIUnit {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<SIUnit>(Unit::VT_UNIT, Some(SIUnit::NONE))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Unit<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<SIPrefix>("prefix", Self::VT_PREFIX, false)?
                .visit_field::<SIUnit>("unit", Self::VT_UNIT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UnitArgs {
        pub prefix: SIPrefix,
        pub unit: SIUnit,
    }
    impl<'a> Default for UnitArgs {
        #[inline]
        fn default() -> Self {
            UnitArgs {
                prefix: SIPrefix::NONE,
                unit: SIUnit::NONE,
            }
        }
    }

    pub struct UnitBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnitBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_prefix(&mut self, prefix: SIPrefix) {
            self.fbb_
                .push_slot::<SIPrefix>(Unit::VT_PREFIX, prefix, SIPrefix::NONE);
        }
        #[inline]
        pub fn add_unit(&mut self, unit: SIUnit) {
            self.fbb_
                .push_slot::<SIUnit>(Unit::VT_UNIT, unit, SIUnit::NONE);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UnitBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UnitBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Unit<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Unit<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Unit");
            ds.field("prefix", &self.prefix());
            ds.field("unit", &self.unit());
            ds.finish()
        }
    }
    pub enum NumberRangeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NumberRange<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NumberRange<'a> {
        type Inner = NumberRange<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> NumberRange<'a> {
        pub const VT_MIN: flatbuffers::VOffsetT = 4;
        pub const VT_MAX: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NumberRange { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args NumberRangeArgs,
        ) -> flatbuffers::WIPOffset<NumberRange<'bldr>> {
            let mut builder = NumberRangeBuilder::new(_fbb);
            builder.add_max(args.max);
            builder.add_min(args.min);
            builder.finish()
        }

        #[inline]
        pub fn min(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(NumberRange::VT_MIN, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn max(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(NumberRange::VT_MAX, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for NumberRange<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<f64>("min", Self::VT_MIN, false)?
                .visit_field::<f64>("max", Self::VT_MAX, false)?
                .finish();
            Ok(())
        }
    }
    pub struct NumberRangeArgs {
        pub min: f64,
        pub max: f64,
    }
    impl<'a> Default for NumberRangeArgs {
        #[inline]
        fn default() -> Self {
            NumberRangeArgs { min: 0.0, max: 0.0 }
        }
    }

    pub struct NumberRangeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NumberRangeBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_min(&mut self, min: f64) {
            self.fbb_.push_slot::<f64>(NumberRange::VT_MIN, min, 0.0);
        }
        #[inline]
        pub fn add_max(&mut self, max: f64) {
            self.fbb_.push_slot::<f64>(NumberRange::VT_MAX, max, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> NumberRangeBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            NumberRangeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NumberRange<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NumberRange<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NumberRange");
            ds.field("min", &self.min());
            ds.field("max", &self.max());
            ds.finish()
        }
    }
    pub enum NumberOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Number<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Number<'a> {
        type Inner = Number<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Number<'a> {
        pub const VT_VALUE: flatbuffers::VOffsetT = 4;
        pub const VT_UNIT: flatbuffers::VOffsetT = 6;
        pub const VT_DECIMALS: flatbuffers::VOffsetT = 8;
        pub const VT_RANGE: flatbuffers::VOffsetT = 10;
        pub const VT_WHITELIST: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Number { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args NumberArgs<'args>,
        ) -> flatbuffers::WIPOffset<Number<'bldr>> {
            let mut builder = NumberBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.whitelist {
                builder.add_whitelist(x);
            }
            if let Some(x) = args.range {
                builder.add_range(x);
            }
            if let Some(x) = args.unit {
                builder.add_unit(x);
            }
            builder.add_decimals(args.decimals);
            builder.finish()
        }

        #[inline]
        pub fn value(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<f64>(Number::VT_VALUE, Some(0.0)).unwrap() }
        }
        #[inline]
        pub fn unit(&self) -> Option<Unit<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Unit>>(Number::VT_UNIT, None)
            }
        }
        #[inline]
        pub fn decimals(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(Number::VT_DECIMALS, Some(0)).unwrap() }
        }
        #[inline]
        pub fn range(&self) -> Option<NumberRange<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<NumberRange>>(Number::VT_RANGE, None)
            }
        }
        #[inline]
        pub fn whitelist(&self) -> Option<flatbuffers::Vector<'a, f64>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(
                        Number::VT_WHITELIST,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Number<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<f64>("value", Self::VT_VALUE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Unit>>("unit", Self::VT_UNIT, false)?
                .visit_field::<u8>("decimals", Self::VT_DECIMALS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<NumberRange>>(
                    "range",
                    Self::VT_RANGE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(
                    "whitelist",
                    Self::VT_WHITELIST,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct NumberArgs<'a> {
        pub value: f64,
        pub unit: Option<flatbuffers::WIPOffset<Unit<'a>>>,
        pub decimals: u8,
        pub range: Option<flatbuffers::WIPOffset<NumberRange<'a>>>,
        pub whitelist: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    }
    impl<'a> Default for NumberArgs<'a> {
        #[inline]
        fn default() -> Self {
            NumberArgs {
                value: 0.0,
                unit: None,
                decimals: 0,
                range: None,
                whitelist: None,
            }
        }
    }

    pub struct NumberBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NumberBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_value(&mut self, value: f64) {
            self.fbb_.push_slot::<f64>(Number::VT_VALUE, value, 0.0);
        }
        #[inline]
        pub fn add_unit(&mut self, unit: flatbuffers::WIPOffset<Unit<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Unit>>(Number::VT_UNIT, unit);
        }
        #[inline]
        pub fn add_decimals(&mut self, decimals: u8) {
            self.fbb_.push_slot::<u8>(Number::VT_DECIMALS, decimals, 0);
        }
        #[inline]
        pub fn add_range(&mut self, range: flatbuffers::WIPOffset<NumberRange<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<NumberRange>>(Number::VT_RANGE, range);
        }
        #[inline]
        pub fn add_whitelist(
            &mut self,
            whitelist: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f64>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Number::VT_WHITELIST, whitelist);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> NumberBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            NumberBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Number<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Number<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Number");
            ds.field("value", &self.value());
            ds.field("unit", &self.unit());
            ds.field("decimals", &self.decimals());
            ds.field("range", &self.range());
            ds.field("whitelist", &self.whitelist());
            ds.finish()
        }
    }
    pub enum TriggerOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Trigger<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Trigger<'a> {
        type Inner = Trigger<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Trigger<'a> {
        pub const VT_REFRESH: flatbuffers::VOffsetT = 4;
        pub const VT_RANGE: flatbuffers::VOffsetT = 6;
        pub const VT_WHITELIST: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Trigger { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TriggerArgs<'args>,
        ) -> flatbuffers::WIPOffset<Trigger<'bldr>> {
            let mut builder = TriggerBuilder::new(_fbb);
            builder.add_refresh(args.refresh);
            if let Some(x) = args.whitelist {
                builder.add_whitelist(x);
            }
            if let Some(x) = args.range {
                builder.add_range(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn refresh(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(Trigger::VT_REFRESH, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn range(&self) -> Option<NumberRange<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<NumberRange>>(Trigger::VT_RANGE, None)
            }
        }
        #[inline]
        pub fn whitelist(&self) -> Option<flatbuffers::Vector<'a, f64>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(
                        Trigger::VT_WHITELIST,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Trigger<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<f64>("refresh", Self::VT_REFRESH, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<NumberRange>>(
                    "range",
                    Self::VT_RANGE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(
                    "whitelist",
                    Self::VT_WHITELIST,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TriggerArgs<'a> {
        pub refresh: f64,
        pub range: Option<flatbuffers::WIPOffset<NumberRange<'a>>>,
        pub whitelist: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    }
    impl<'a> Default for TriggerArgs<'a> {
        #[inline]
        fn default() -> Self {
            TriggerArgs {
                refresh: 0.0,
                range: None,
                whitelist: None,
            }
        }
    }

    pub struct TriggerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TriggerBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_refresh(&mut self, refresh: f64) {
            self.fbb_
                .push_slot::<f64>(Trigger::VT_REFRESH, refresh, 0.0);
        }
        #[inline]
        pub fn add_range(&mut self, range: flatbuffers::WIPOffset<NumberRange<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<NumberRange>>(Trigger::VT_RANGE, range);
        }
        #[inline]
        pub fn add_whitelist(
            &mut self,
            whitelist: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f64>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Trigger::VT_WHITELIST, whitelist);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TriggerBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TriggerBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Trigger<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Trigger<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Trigger");
            ds.field("refresh", &self.refresh());
            ds.field("range", &self.range());
            ds.field("whitelist", &self.whitelist());
            ds.finish()
        }
    }
    pub enum StringOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct String<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for String<'a> {
        type Inner = String<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> String<'a> {
        pub const VT_VALUE: flatbuffers::VOffsetT = 4;
        pub const VT_WHITELIST: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            String { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args StringArgs<'args>,
        ) -> flatbuffers::WIPOffset<String<'bldr>> {
            let mut builder = StringBuilder::new(_fbb);
            if let Some(x) = args.whitelist {
                builder.add_whitelist(x);
            }
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(String::VT_VALUE, None)
            }
        }
        #[inline]
        pub fn whitelist(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(String::VT_WHITELIST, None)
            }
        }
    }

    impl flatbuffers::Verifiable for String<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("whitelist", Self::VT_WHITELIST, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StringArgs<'a> {
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
        pub whitelist: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for StringArgs<'a> {
        #[inline]
        fn default() -> Self {
            StringArgs {
                value: None,
                whitelist: None,
            }
        }
    }

    pub struct StringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StringBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(String::VT_VALUE, value);
        }
        #[inline]
        pub fn add_whitelist(
            &mut self,
            whitelist: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(String::VT_WHITELIST, whitelist);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> StringBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            StringBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<String<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for String<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("String");
            ds.field("value", &self.value());
            ds.field("whitelist", &self.whitelist());
            ds.finish()
        }
    }
    pub enum VectorF32Offset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct VectorF32<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for VectorF32<'a> {
        type Inner = VectorF32<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> VectorF32<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            VectorF32 { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args VectorF32Args<'args>,
        ) -> flatbuffers::WIPOffset<VectorF32<'bldr>> {
            let mut builder = VectorF32Builder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn values(&self) -> Option<flatbuffers::Vector<'a, f32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                        VectorF32::VT_VALUES,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for VectorF32<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                    "values",
                    Self::VT_VALUES,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct VectorF32Args<'a> {
        pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    }
    impl<'a> Default for VectorF32Args<'a> {
        #[inline]
        fn default() -> Self {
            VectorF32Args { values: None }
        }
    }

    pub struct VectorF32Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VectorF32Builder<'a, 'b, A> {
        #[inline]
        pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(VectorF32::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> VectorF32Builder<'a, 'b, A> {
            let start = _fbb.start_table();
            VectorF32Builder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<VectorF32<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for VectorF32<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("VectorF32");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
} // pub mod panduza
